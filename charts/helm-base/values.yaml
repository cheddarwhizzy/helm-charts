# Global configuration applied to all resources
global:
  # Image pull secrets for private registries
  imagePullSecrets: []
  # Global image configuration
  image:
    # repository: "" # Global image repository override
    tag: latest # Global image tag override
  # Global configMaps to be created
  configMaps: []
  # Global secrets to be created
  secrets: []
  # DNS policy for pods (None, Default, ClusterFirst, ClusterFirstWithHostNet)
  # dnsPolicy: "None"
  # DNS configuration for custom DNS settings
  # dnsConfig: {}
  # Global monitoring configuration
  monitoring:
    # slack_channel: "" # Global Slack channel for alerts
  externalSecrets: {}

# Override the chart name
nameOverride: 
# Override the full name of the chart
fullnameOverride: 

# Number of replicas for the deployment
replicaCount: 1
# API version for the deployment resource
apiVersion: apps/v1
# Kind of workload (Deployment, StatefulSet, Job, CronJob, or DaemonSet)
kind: Deployment

# Services configuration - supports multiple services
services: []
# Preferred map-based services schema (recommended for deep merging):
# services:
#   web:
#     type: ClusterIP # ClusterIP, NodePort, LoadBalancer, or ExternalName
#     ports:
#     - name: http
#       port: 8080
#       targetPort: 8080
#       protocol: TCP
#   api:
#     type: LoadBalancer
#     ports:
#     - name: api
#       port: 8080
#       targetPort: 8080
#       protocol: TCP
# Legacy list-based services schema (still supported):
# - name: default
#   type: ClusterIP # ClusterIP, NodePort, LoadBalancer, or ExternalName
#   ports:
#   - name: gotty
#     port: 8080
#     targetPort: 8080
#     protocol: TCP
#     nodePort: 30080 # Optional: specify nodePort for NodePort services

# StatefulSet specific configuration
statefulSet: {}
  # updateStrategy: OnDelete # Update strategy for StatefulSet
  # serviceName: "" # Service name for StatefulSet

# Job specific configuration
backoffLimit: 3 # Number of retries for failed jobs
activeDeadlineSeconds: 1800 # Maximum time a job can run

# CronJob specific configuration
schedule: "" # Cron schedule expression (required for CronJob)
concurrencyPolicy: "" # Allow, Forbid, or Replace
successfulJobsHistoryLimit: 3 # Number of successful jobs to retain
failedJobsHistoryLimit: 1 # Number of failed jobs to retain
startingDeadlineSeconds: 0 # Deadline for starting the job
suspend: false # Suspend the cron job
ttlSecondsAfterFinished: 0 # TTL for finished jobs

# Volumes for deployments. Must also specify in initContainers/containers below
volumes: []
# Example legacy list-based volume configurations (still supported):
# - name: some-volume
#   hostPath: 
#     path: /path/to/mount
#     type: DirectoryOrCreate
# - name: some-configmap
#   configMap:
#     name: configmap-name
#     defaultMode: 420
#     items: []
# - name: some-emptydir
#   emptyDir:
#     sizeLimit: "1Gi"
# - name: ephemeral-storage
#   ephemeral:
#     volumeClaimTemplate:
#       metadata:
#         labels:
#           type: ephemeral
#       spec:
#         accessModes: ["ReadWriteOnce"]
#         resources:
#           requests:
#             storage: 1Gi
#         storageClassName: fast-ssd
# - name: csi-volume
#   csi:
#     driver: ebs.csi.aws.com
#     volumeAttributes:
#       type: gp3
#       size: "10Gi"
#       encrypted: "true"
#     readOnly: false
# - name: volume-snapshot
#   volumeSnapshot:
#     name: my-snapshot
# - name: all-in-one
#   projected:
#     defaultMode: 420
#     sources:
#     - secret:
#         name: mysecret
#         items:
#           - key: username
#             path: my-group/my-username
#             mode: 511
#     - secret:
#         name: mysecret2
#         items:
#           - key: password
#             path: my-group/my-password
#             mode: 511
#     - configMap:
#         name: myconfig
#         items:
#           - key: config
#             path: config.json
# - name: generic-ephemeral
#   genericEphemeral:
#     volumeClaimTemplate:
#       metadata:
#         labels:
#           type: generic-ephemeral
#       spec:
#         accessModes: ["ReadWriteOnce"]
#         resources:
#           requests:
#             storage: 1Gi
#
# Preferred map-based volumes schema (recommended for deep merging):
# volumes:
#   data:
#     persistentVolumeClaim:
#       claimName: data-pvc
#   config:
#     configMap:
#       name: app-config

# Volume claim templates for StatefulSets
volumeClaimTemplates: []
# Preferred map-based volumeClaimTemplates schema (recommended for deep merging):
# volumeClaimTemplates:
#   data:
#     metadata:
#       name: data
#     spec:
#       accessModes: ["ReadWriteOnce"]
#       resources:
#         requests:
#           storage: 10Gi
#   logs:
#     metadata:
#       name: logs
#     spec:
#       accessModes: ["ReadWriteOnce"]
#       resources:
#         requests:
#           storage: 5Gi
# Legacy list-based volumeClaimTemplates schema (still supported):
# - metadata:
#     name: data
#   spec:
#     accessModes: ["ReadWriteOnce"]
#     resources:
#       requests:
#         storage: 10Gi

# Config Maps to be mounted as env vars or files in the pods
configMaps: []
# Preferred map-based configMaps schema (recommended for deep merging):
# configMaps:
#   app-config:
#     data:
#       config.json: |
#         {"apiUrl":"https://my.domain.com"}
#     labels: {} # Optional labels
#     annotations: {} # Optional annotations
#   feature-flags:
#     data:
#       features.yaml: |
#         enabled: true
# Legacy list-based configMaps schema (still supported):
# - name: some-configmap
#   data:
#     config.json: |
#       {"apiUrl":"https://my.domain.com"}
#   labels: {} # Optional labels
#   annotations: {} # Optional annotations

# Secrets to be mounted as env vars or files in the pods
secrets: []
# Preferred map-based secrets schema (recommended for deep merging):
# secrets:
#   db-credentials:
#     type: Opaque
#     data:
#       username: dXNlcm5hbWU= # base64 encoded
#       password: cGFzc3dvcmQ= # base64 encoded
#   api-keys:
#     type: Opaque
#     data:
#       apiKey: YWJjMTIz # base64 encoded
# Legacy list-based secrets schema (still supported):
# - name: some-secret
#   type: Opaque
#   data:
#     username: dXNlcm5hbWU= # base64 encoded
#     password: cGFzc3dvcmQ= # base64 encoded

# External Secret Store configuration
secretStore:
  create: false # Create external secret store
  # fullname: aws-parameter-store # default ClusterSecretStore 
  name: "" # Secret store name
  service: ParameterStore # Service type (ParameterStore, SecretsManager)
  region: us-west-2 # AWS region

# External Secrets configuration for AWS Parameter Store
externalSecrets: {}
  # auth: # Kubernetes Secret name to be created
  #   data:
  #     SOME_ENV_VAR: /ci/<service-name>/some_env_var


# Service Account configuration
serviceAccount:
  create: false # Create service account
  # name: default # Service account name (defaults to fullname)
  annotations: {} # Annotations for service account

# Termination grace period for pods (seconds)
terminationGracePeriodSeconds: 30

# Image configuration
image: {}
  # tag: latest # Image tag
  # repository: some.registry.com/my-image # Image repository

# Image pull secrets for private registries
imagePullSecrets: []
# - name: some-image-pull-secret

# Environment variables from ConfigMaps or Secrets
envFrom: {} # mount in additional ConfigMap/Secret env vars (supports flat list or grouped map-of-lists)
# Preferred grouped envFrom schema (recommended for deep merging):
# envFrom:
#   base:
#     - configMapRef:
#         name: special-config # or fullname: other-service-configmap
#   secrets:
#     - secretRef:
#         name: secret-config # or fullname: other-service-secrets
# Legacy flat list schema (still supported):
# - configMapRef:
#     name: special-config
# - secretRef:
#     name: secret-config

# Environment variables (supports grouped maps for deep merging)
env: {}
  # Preferred grouped env schema (recommended):
  # env:
  #   base:
  #     BRANCH: integration
  #   observability:
  #     OTEL_EXPORTER_OTLP_ENDPOINT: "http://otel-collector:4317"

# Pod affinity configuration
# affinity: |
#   podAntiAffinity:
#     requiredDuringSchedulingIgnoredDuringExecution:
#     - labelSelector:
#         matchExpressions:
#         - key: app
#           operator: In
#           values:
#           - {{ .Values.serviceName }}
#       topologyKey: "kubernetes.io/hostname"

# Pod tolerations
tolerations: []
# Node selector for pod placement
nodeSelector: {}
# Use host network
hostNetwork: false
# Use host PID
hostPID: false
# Priority class name
priorityClassName: ""
# Host aliases for DNS resolution
hostAliases: []
# Common annotations applied to all resources
commonAnnotations: {}
  # deployment_date: '{{ now | date "2006-01-02 15:04:05" }}'
# Pod-specific annotations
podAnnotations: {}
# Pod-specific labels
podLabels: {}
# Restart policy for pods
restartPolicy: ""

# Pod Security Standards
# 
# POD SECURITY GRADUAL ADOPTION GUIDE:
# 1. Start with 'baseline' standard (current default)
# 2. Use 'warn' mode first to see what would be blocked
# 3. Gradually move to 'enforce' mode as you fix issues
# 4. Eventually upgrade to 'restricted' standard for maximum security
#
# Standards:
# - privileged: Most permissive (legacy behavior)
# - baseline: Minimally restrictive (recommended starting point)
# - restricted: Heavily restricted (maximum security)
podSecurity:
  enabled: false # Enable Pod Security Standards
  standard: baseline # restricted, baseline, privileged (baseline for compatibility)
  enforce: baseline # Enforcement level (baseline for compatibility)
  audit: baseline # Audit level
  warn: baseline # Warning level

# Security contexts (relaxed defaults for backward compatibility)
# 
# SECURITY GRADUAL ADOPTION GUIDE:
# 1. Start with current relaxed defaults (no security contexts applied)
# 2. Gradually uncomment and configure security settings as your images are updated
# 3. Recommended progression:
#    a) First: Enable seccompProfile (RuntimeDefault)
#    b) Second: Set runAsNonRoot: true
#    c) Third: Set specific runAsUser/runAsGroup
#    d) Fourth: Enable readOnlyRootFilesystem (requires writable volume mounts)
#    e) Fifth: Drop ALL capabilities and add only what's needed
#    f) Finally: Enable allowPrivilegeEscalation: false
#
# For maximum security, uncomment all settings and ensure your containers:
# - Run as non-root user
# - Have writable directories mounted as volumes
# - Don't require privileged operations
# - Use minimal required capabilities
securityContext:
  # Pod-level security context (minimal defaults)
  podSecurityContext:
    # runAsNonRoot: true # Uncomment to enforce non-root
    # runAsUser: 1000 # Uncomment to set specific user
    # runAsGroup: 1000 # Uncomment to set specific group
    # fsGroup: 2000 # Uncomment to set file system group
    # fsGroupChangePolicy: OnRootMismatch # When to change ownership
    # seccompProfile:
    #   type: RuntimeDefault # Seccomp profile type
    # supplementalGroups: [] # Additional groups
    # sysctls: [] # System controls
    # seLinuxOptions: {} # SELinux options
    # windowsOptions: {} # Windows-specific options
  # Container-level security context (minimal defaults)
  containerSecurityContext:
    # allowPrivilegeEscalation: false # Uncomment to disable privilege escalation
    # readOnlyRootFilesystem: true # Uncomment for read-only root filesystem
    # runAsNonRoot: true # Uncomment to enforce non-root
    # runAsUser: 1000 # Uncomment to set specific user
    # runAsGroup: 1000 # Uncomment to set specific group
    # capabilities:
    #   drop:
    #     - ALL # Drop all capabilities
    #   add: [] # Add specific capabilities
    # seccompProfile:
    #   type: RuntimeDefault # Seccomp profile
    # seLinuxOptions: {} # SELinux options
    # windowsOptions: {} # Windows-specific options
    # procMount: Default # Proc mount type
  # You can also set global.securityContext.{podSecurityContext,containerSecurityContext}
  # to apply security defaults across multiple aliased subcharts.

# Progress deadline for deployment (seconds)
progressDeadlineSeconds: 180
# Minimum ready seconds before pod is considered available
# minReadySeconds: 0
# Number of old replicas to retain
revisionHistoryLimit: 10

# Deployment strategy
strategy:
  type: RollingUpdate # RollingUpdate or Recreate
  maxUnavailable: 0 # Maximum unavailable pods during update
  maxSurge: # Maximum surge pods during update

# Init containers configuration
initContainers: []
# Preferred map-based initContainers schema (recommended):
# initContainers:
#   migrator:
#     image: registry.domain.com/migrator:tag
#     env: {}
#     resources: {}
#     volumeMounts: {}
# Main containers configuration
containers: []
# Preferred map-based containers schema (recommended):
# containers:
#   main:
#     image: registry.domain.com/image:tag
#     command:
#     - sh
#     - -c
#     - |
#       echo hello
#       ./run_me.sh
#     volumeMounts:
#       src:
#         mountPath: /app
#       some-configmap:
#         mountPath: /etc/myapp
#     ports:
#     - containerPort: 8080
#       name: http
#     env:
#       base:
#         ENV_VAR: "value"
#     resources:
#       requests:
#         memory: "64Mi"
#         cpu: "250m"
#       limits:
#         memory: "128Mi"
#         cpu: "500m"
#     waitFor:
#       port: 8080
#       initialDelaySeconds: 10
#     startupProbe:
#       httpGet:
#         path: /health
#         port: 8080
#       initialDelaySeconds: 10
#       periodSeconds: 5
#       timeoutSeconds: 5
#       failureThreshold: 30
#       successThreshold: 1
#     livenessProbe:
#       httpGet:
#         path: /health
#         port: 8080
#         httpHeaders:
#           - name: Custom-Header
#             value: "value"
#       initialDelaySeconds: 30
#       periodSeconds: 10
#       timeoutSeconds: 5
#       failureThreshold: 3
#       successThreshold: 1
#     readinessProbe:
#       httpGet:
#         path: /ready
#         port: 8080
#         httpHeaders:
#           - name: Custom-Header
#             value: "value"
#       initialDelaySeconds: 5
#       periodSeconds: 5
#       timeoutSeconds: 5
#       failureThreshold: 3
#       successThreshold: 1
#
# Legacy list-based containers schema (still supported):
# containers:
# - name: some-thing
#   image: registry.domain.com/image:tag
#   command:
#   - sh
#   - -c
#   - |
#     echo hello
#     ./run_me.sh
#   volumeMounts:
#   - name: src
#     mountPath: /app
#   - name: some-configmap
#     mountPath: /etc/myapp
#   ports:
#   - containerPort: 8080
#     name: http
#   env:
#   - name: ENV_VAR
#     value: "value"
#   resources:
#     requests:
#       memory: "64Mi"
#       cpu: "250m"
#     limits:
#       memory: "128Mi"
#       cpu: "500m"


# Role based access control. Requires a serviceaccount
rbac:
  create: false # Create RBAC resources
  type: "" # default Role or "cluster" for ClusterRole
  rules: [] # RBAC rules
  # Example RBAC rules:
  # - apiGroups: [""]
  #   resources: ["pods", "pods/exec", "pods/log"]
  #   verbs: ["*"]

# Horizontal Pod Autoscaler configuration
hpa:
  enabled: false # Enable HPA
  kind: Deployment # or 'StatefulSet'
  minReplicaCount: 1 # Minimum replicas
  maxReplicaCount: 10 # Maximum replicas
  metrics: # Scaling metrics
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 80
  - type: Resource
    resource:
      name: memory
      target:
        type: AverageValue
        averageValue: "512Mi"
  # - type: Pods
  #   pods:
  #     metricName: http_requests
  #     target:
  #       type: AverageValue
  #       averageValue: "10"

# Pod Disruption Budget configuration
podDisruptionBudget: 
  enabled: false # Enable PDB
  minAvailable: 1 # Minimum available pods
  # maxUnavailable: 1 # Maximum unavailable pods

# Network Policy configuration
networkPolicy:
  enabled: false # Enable network policy (template also accepts legacy 'enable' flag)
  policy: | # Network policy specification
    podSelector: {}
    policyTypes:
    - Ingress
    ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            nginx: "true"

# Ingress configuration
ingress:
  enabled: false # Enable ingress
  secretName: # TLS secret name
  subdomain: # Subdomain for the service
  domain: # Domain for the service
  class: nginx # Ingress class (nginx, haproxy, etc.)
  port: 80 # Default port for ingress
  annotations: {} # Ingress annotations
    # external-dns.alpha.kubernetes.io/target: nginx.lb.domain.com
    # external-dns.alpha.kubernetes.io/ttl: "60"
    # cert-manager.io/cluster-issuer: letsencrypt-prod-http
    # certmanager.k8s.io/cluster-issuer: letsencrypt-prod-http
    # prometheus.io/probe: "true"
    # ingress.kubernetes.io/cors-enable: "true"
    # ingress.kubernetes.io/config-backend: |
    #   acl network_allowed src 10.0.0.0/16 172.254.199.202 38.142.252.242 71.183.39.85
    #   http-request deny if !network_allowed
  routes: [] # Ingress routes
    # Preferred map-based routes schema (recommended for deep merging):
    # routes:
    #   web:
    #     host: "{{ .Values.ingress.subdomain }}.{{ .Values.ingress.domain }}"
    #     port: 3000
    #     path: /
    #     pathType: Prefix
    #     service: web # Service name to route to
    #   api:
    #     host: "api.{{ .Values.ingress.domain }}"
    #     port: 8080
    #     path: /api
    #     pathType: Prefix
    #     service: api
    #     secretName: custom-tls # Override TLS secret
    #     aliases: [] # Additional host aliases for this route
    #     annotations: {} # Route-specific annotations
    # Legacy list-based routes schema (still supported):
    # - name: default
    #   host: "{{ .Values.ingress.subdomain }}.{{ .Values.ingress.domain }}"
    #   port: 3000
    #   path: /
    #   pathType: Prefix
    #   service: web # Service name to route to
    #   serviceFullName: custom-service # Override service name
    #   secretName: custom-tls # Override TLS secret
    #   aliases: [] # Additional host aliases for this route
    #   annotations: {} # Route-specific annotations
  aliases: [] # Additional host aliases
  tls: false # Enable TLS
  # privateIngressRules: | # Private ingress rules for haproxy
  #   acl network_allowed src 10.0.0.0/16 172.254.199.202 38.142.252.242 71.183.39.85
  #   http-request deny if !network_allowed

# VirtualService configuration for Istio
virtualservice:
  enabled: false # Enable VirtualService
  host: # Host for the VirtualService
  gateway: # Istio gateway
  port: 80 # Port for the service
  annotations: {} # VirtualService annotations
  routes: [] # VirtualService routes
    # Preferred map-based routes schema (recommended for deep merging):
    # routes:
    #   web:
    #     host: "{{ .Values.virtualservice.host }}"
    #     port: 3000
    #     path: /
    #     gateway: mesh
    #     service: web # Service name to route to
    #   api:
    #     host: "api.example.com"
    #     port: 8080
    #     path: /api
    #     service: api
    #     tls: false # Enable TLS for this route
    #     corsPolicy:
    #       allowOrigins:
    #       - exact: "https://example.com"
    #     retries:
    #       attempts: 3
    #       perTryTimeout: 2s
    #     timeout: 30s
    # Legacy list-based routes schema (still supported):
    # - name: default
    #   host: "{{ .Values.virtualservice.host }}"
    #   port: 3000
    #   path: /
    #   gateway: mesh
    #   service: web # Service name to route to
    #   serviceFullName: custom-service # Override service name
    #   tls: false # Enable TLS for this route
    #   corsPolicy:
    #     allowOrigins:
    #     - exact: "https://example.com"
    #     allowMethods:
    #     - GET
    #     - POST
    #     allowHeaders:
    #     - authorization
    #     - content-type
    #   retries:
    #     attempts: 3
    #     perTryTimeout: 2s
    #   timeout: 30s
    #   aliases: [] # Additional host aliases for this route
    #   annotations: {} # Route-specific annotations
  aliases: [] # Additional host aliases

# Istio AuthorizationPolicy configuration for IP whitelisting
authorizationPolicy:
  enabled: false # Enable AuthorizationPolicy
  action: ALLOW # Action to take (ALLOW or DENY)
  selector: {} # Workload selector (matches pod labels)
    # Example:
    # matchLabels:
    #   app.kubernetes.io/name: myapp
  annotations: {} # AuthorizationPolicy annotations
  # Simple IP whitelist configuration (recommended)
  allowedIPs: [] # List of CIDR blocks to allow
    # Example:
    # - 192.168.1.100/32
    # - 10.0.0.0/24
  # Advanced rules configuration (optional, overrides allowedIPs if set)
  rules: [] # Custom authorization rules
    # Example:
    # - from:
    #     - source:
    #         remoteIpBlocks:
    #           - 192.168.1.100/32
    #     - source:
    #         principals:
    #           - cluster.local/ns/default/sa/myapp
    #   to:
    #     - operation:
    #         methods: ["GET", "POST"]

# Istio EnvoyFilter configuration
# Used to configure Envoy proxy behavior, e.g., for X-Forwarded-For header handling
envoyFilters: {}
  # Example XFF configuration for IP whitelisting:
  # xff-ip-whitelist-filter:
  #   enabled: true
  #   workloadSelector:
  #     labels:
  #       envoy.filters.enable-whitelisted-filter: "true"
  #   configPatches:
  #     - applyTo: NETWORK_FILTER
  #       match:
  #         context: SIDECAR_INBOUND
  #         listener:
  #           filterChain:
  #             filter:
  #               name: envoy.filters.network.http_connection_manager
  #       patch:
  #         operation: MERGE
  #         value:
  #           typed_config:
  #             "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
  #             xff_num_trusted_hops: 3
  #             use_remote_address: true
  #
  # Example gzip compression filter:
  # gzip-filter:
  #   enabled: true
  #   workloadSelector:
  #     labels:
  #       envoy.filters.enable-gzip-filter: "true"
  #   configPatches:
  #     - applyTo: HTTP_FILTER
  #       match:
  #         context: SIDECAR_INBOUND
  #         listener:
  #           filterChain:
  #             filter:
  #               name: envoy.filters.network.http_connection_manager
  #               subFilter:
  #                 name: envoy.filters.http.router
  #       patch:
  #         operation: INSERT_BEFORE
  #         value:
  #           name: envoy.filters.http.compressor
  #           typed_config:
  #             '@type': type.googleapis.com/envoy.extensions.filters.http.compressor.v3.Compressor
  #             compressor_library:
  #               name: text_optimized
  #               typed_config:
  #                 '@type': type.googleapis.com/envoy.extensions.compression.gzip.compressor.v3.Gzip
  #             remove_accept_encoding_header: true

# Gateway API configuration
gatewayApi:
  enabled: false # Enable Gateway API resources
  apiVersion: gateway.networking.k8s.io/v1 # API version for Gateway/HTTPRoute
  gatewayClassName: "" # Default GatewayClass name
  port: 80 # Default listener/backend port
  gatewayAnnotations: {} # Global annotations applied to every Gateway
  httpRouteAnnotations: {} # Global annotations applied to every HTTPRoute
  gateways: [] # Gateway definitions
    # Preferred map-based gateways schema (recommended for deep merging):
    # gateways:
    #   public:
    #     gatewayClassName: istio
    #     namespace: istio-gateway
    #     labels: {}
    #     annotations: {}
    #     addresses:
    #       - type: Hostname
    #         value: public-gateway.example.com
    #     listeners:
    #       - name: http
    #         protocol: HTTP
    #         port: 80
    #         hostname: "app.example.com"
    #   internal:
    #     gatewayClassName: istio
    #     namespace: istio-gateway
    #     listeners:
    #       - name: http
    #         protocol: HTTP
    #         port: 80
    # Legacy list-based gateways schema (still supported):
    # - name: public
    #   gatewayClassName: istio
    #   namespace: istio-gateway
    #   labels: {}
    #   annotations: {}
    #   addresses:
    #     - type: Hostname
    #       value: public-gateway.example.com
    #   listeners:
    #     - name: http
    #       protocol: HTTP
    #       port: 80
    #       hostname: "app.example.com"
    #       allowedRoutes:
    #         namespaces:
    #           from: Same
    #         kinds:
    #           - kind: HTTPRoute
    #             group: gateway.networking.k8s.io
    #       tls:
    #         mode: Terminate
    #         certificateRefs:
    #           - name: app-cert
    #             kind: Secret
  httpRoutes: [] # HTTPRoute definitions
    # Preferred map-based httpRoutes schema (recommended for deep merging):
    # httpRoutes:
    #   web:
    #     hostnames:
    #       - app.example.com
    #     parentRefs:
    #       - name: public
    #         namespace: istio-gateway
    #         sectionName: http
    #     rules:
    #       - matches:
    #           - path:
    #               type: PathPrefix
    #               value: /
    #         backendRefs:
    #           - service: web
    #             port: 3000
    #   api:
    #     hostnames:
    #       - api.example.com
    #     parentRefs:
    #       - name: public
    #         sectionName: http
    #     rules:
    #       - matches:
    #           - path:
    #               type: PathPrefix
    #               value: /api
    #         backendRefs:
    #           - service: api
    #             port: 8080
    # Legacy list-based httpRoutes schema (still supported):
    # - name: default
    #   hostnames:
    #     - app.example.com
    #   parentRefs:
    #     - name: public
    #       namespace: istio-gateway
    #       sectionName: http
    #   rules:
    #     - matches:
    #         - path:
    #             type: PathPrefix
    #             value: /
    #       filters:
    #         - type: RequestHeaderModifier
    #           requestHeaderModifier:
    #             add:
    #               x-env: prod
    #       backendRefs:
    #         - service: web # Uses <fullname>-web service
    #           port: 3000
    #           weight: 1

# Optional Telemetry configuration for Istio access logs
telemetry:
  enabled: false # Enable telemetry configuration
  defaultProvider: "envoy" # Default telemetry provider
  annotations: {} # Annotations for telemetry resources
  routes: [] # Telemetry routes configuration
    # Preferred map-based routes schema (recommended for deep merging):
    # routes:
    #   access-logs:
    #     providers:
    #       - name: envoy
    #     filter:
    #       expression: "response.code >= 400"
    #     annotations: {} # Route-specific annotations
    #   error-logs:
    #     providers:
    #       - name: envoy
    #     filter:
    #       expression: "response.code >= 500"
    # Legacy list-based routes schema (still supported):
    # - name: access-logs
    #   providers:
    #     - name: envoy
    #   filter:
    #     expression: "response.code >= 400"
    #   annotations: {} # Route-specific annotations

# Storage class configuration
storageclass:
  create: false # Create storage class
  provisioner: "" # Storage provisioner
  name: "" # Storage class name
  isDefault: false # Set as default storage class
  parameters: {} # Storage class parameters
  reclaimPolicy: Delete # Reclaim policy (Delete, Retain)
  volumeBindingMode: Immediate # Volume binding mode (Immediate, WaitForFirstConsumer)

# Custom Resource Definitions
crds:
  enabled: false # Enable CRD creation
  crds: [] # List of CRDs to create
    # Preferred map-based crds schema (recommended for deep merging):
    # crds:
    #   my-crd:
    #     spec:
    #       group: example.com
    #       version: v1
    #       scope: Namespaced
    #       names:
    #         plural: mycrds
    #         singular: mycrd
    #         kind: MyCrd
    #   another-crd:
    #     spec:
    #       group: example.com
    #       version: v1
    #       scope: Cluster
    #       names:
    #         plural: anothercrds
    #         singular: anothercrd
    #         kind: AnotherCrd
    # Legacy list-based crds schema (still supported):
    # - name: my-crd
    #   spec:
    #     group: example.com
    #     version: v1
    #     scope: Namespaced
    #     names:
    #       plural: mycrds
    #       singular: mycrd
    #       kind: MyCrd

# Raw Resources - Maximum flexibility for custom resources
# This allows you to define any Kubernetes resource with full YAML support
# and automatic commonLabels/commonAnnotations injection
rawResources: {}
# Example configurations:
# rawResources:
#   # ExternalSecret example
#   my-external-secret:
#     type: ExternalSecret
#     apiVersion: external-secrets.io/v1beta1
#     labels:
#       app.kubernetes.io/component: secrets
#     annotations:
#       description: "External secret for database credentials"
#     spec:
#       refreshInterval: 1h
#       secretStoreRef:
#         name: aws-secrets-manager
#         kind: SecretStore
#       target:
#         name: database-secret
#         creationPolicy: Owner
#       data:
#       - secretKey: username
#         remoteRef:
#           key: database/credentials
#           property: username
#       - secretKey: password
#         remoteRef:
#           key: database/credentials
#           property: password
#
#   # Custom CRD example
#   my-custom-resource:
#     type: MyCustomResource
#     apiVersion: mycompany.com/v1
#     spec:
#       replicas: 3
#       image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
#       config:
#         database:
#           host: "{{ .Values.database.host }}"
#           port: "{{ .Values.database.port }}"
#
#   # Service example with advanced features
#   my-advanced-service:
#     type: Service
#     apiVersion: v1
#     spec:
#       type: LoadBalancer
#       loadBalancerClass: "aws-load-balancer"
#       externalTrafficPolicy: Local
#       sessionAffinity: ClientIP
#       sessionAffinityConfig:
#         clientIP:
#           timeoutSeconds: 3600
#       ports:
#       - name: http
#         port: 80
#         targetPort: 8080
#         protocol: TCP
#       - name: https
#         port: 443
#         targetPort: 8443
#         protocol: TCP
#       selector:
#         app: {{ include "helm-base.name" . }}
#
#   # Role example
#   my-custom-role:
#     type: Role
#     apiVersion: rbac.authorization.k8s.io/v1
#     rules:
#     - apiGroups: [""]
#       resources: ["pods", "pods/log"]
#       verbs: ["get", "list", "watch"]
#     - apiGroups: ["apps"]
#       resources: ["deployments"]
#       verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
#
#   # RoleBinding example
#   my-custom-rolebinding:
#     type: RoleBinding
#     apiVersion: rbac.authorization.k8s.io/v1
#     subjects:
#     - kind: ServiceAccount
#       name: {{ include "helm-base.serviceAccountName" . }}
#       namespace: {{ .Release.Namespace }}
#     roleRef:
#       kind: Role
#       name: my-custom-role
#       apiGroup: rbac.authorization.k8s.io

# Pod Security Policy (Not Implemented - template is commented out)
psp:
  enabled: false

# Mutating Webhook Configuration (Not Implemented - template is commented out)
mutatingWebhookConfiguration:
  enabled: false

# Validating Webhook Configuration (Not Implemented - template is commented out)
validatingWebhookConfiguration:
  enabled: false

# Monitoring configuration for Prometheus
monitoring:
  slack_channel: "" # Slack channel for alerts
  alert_name: "" # Base name for alerts
  severity: warning # Default alert severity
  tplConfig: false # Enable template processing for rules
  rules: {} # Custom Prometheus rules
    # Example:
    # my-rule:
    #   groups:
    #   - name: my-group
    #     rules:
    #     - alert: MyAlert
    #       expr: up == 0
    #       for: 5m
    #       labels:
    #         severity: critical
    #       annotations:
    #         summary: "Service is down"
  presets: # Predefined monitoring presets
    redis:
      enabled: false
      name: "" # Redis cluster name
      alert_name: "" # Override alert name
      severity: warning # Override severity
      memory_threshold: 100 # Memory threshold in MB
      cpu_threshold: 80 # CPU threshold percentage
      disable_alerts: [] # List of alerts to disable
      severity_overrides: {} # Override severity for specific alerts
      labels: {} # Additional labels
    rds:
      enabled: false
      name: "" # RDS instance name
      alert_name: "" # Override alert name
      severity: warning # Override severity
      memory_threshold: 100 # Memory threshold in MB
      cpu_threshold: 80 # CPU threshold percentage
      disable_alerts: [] # List of alerts to disable
      severity_overrides: {} # Override severity for specific alerts
      labels: {} # Additional labels
    elasticsearch:
      enabled: false
      name: "" # ES domain name
      alert_name: "" # Override alert name
      severity: warning # Override severity
      free_storage_threshold: 1000 # Free storage threshold in MB
      cpu_threshold: 80 # CPU threshold percentage
      jvm_memory_threshold: 80 # JVM memory threshold percentage
      disable_alerts: [] # List of alerts to disable
      severity_overrides: {} # Override severity for specific alerts
      labels: {} # Additional labels
    dynamodb:
      enabled: false
      name: "" # DynamoDB table name
      alert_name: "" # Override alert name
      severity: warning # Override severity
      read_capacity_threshold: 80 # Read capacity threshold percentage
      write_capacity_threshold: 80 # Write capacity threshold percentage
      disable_alerts: [] # List of alerts to disable
      severity_overrides: {} # Override severity for specific alerts
      labels: {} # Additional labels
    elb:
      enabled: false
      alert_name: "" # Override alert name
      severity: warning # Override severity
      unhealthy_threshold: 0 # Unhealthy targets threshold
      disable_alerts: [] # List of alerts to disable
      severity_overrides: {} # Override severity for specific alerts
      labels: {} # Additional labels
    nginx:
      enabled: false
      alert_name: "" # Override alert name
      severity: warning # Override severity
      error_threshold: 10 # Error threshold count
      disable_alerts: [] # List of alerts to disable
      severity_overrides: {} # Override severity for specific alerts
      labels: {} # Additional labels

# KEDA (Kubernetes Event Driven Autoscaler) configuration
keda:
  enabled: false # Enable KEDA ScaledObject
  pollingInterval: 30 # Polling interval in seconds
  minReplicaCount: 1 # Minimum replicas
  maxReplicaCount: 10 # Maximum replicas
  cooldownPeriod: 300 # Cooldown period in seconds
  triggers: [] # KEDA triggers
    # Example:
    # - type: prometheus
    #   metadata:
    #     serverAddress: http://prometheus:9090
    #     metricName: http_requests_per_second
    #     threshold: '10'

# PodMonitor configuration for Prometheus
podMonitor:
  enabled: false # Enable PodMonitor
  port: http # Port name to scrape
  path: /metrics # Metrics path
  interval: 30s # Scrape interval
  scrapeTimeout: 10s # Scrape timeout
  honorLabels: false # Honor labels from target
  scheme: http # Scheme (http/https)
  labels: {} # Additional labels
  annotations: {} # Additional annotations
  selector: {} # Pod selector overrides
  namespaceSelector: {} # Namespace selector
  sampleLimit: 0 # Sample limit (0 = no limit)
  targetLimit: 0 # Target limit (0 = no limit)
  relabelings: [] # Relabeling rules
  metricRelabelings: [] # Metric relabeling rules
  tlsConfig: {} # TLS configuration
  bearerTokenSecret: {} # Bearer token secret
  basicAuth: {} # Basic auth configuration

# Vertical Pod Autoscaler configuration
vpa:
  enabled: false # Enable VPA
  labels: {} # Additional labels
  annotations: {} # Additional annotations
  updatePolicy:
    updateMode: Auto # Auto, Initial, Off
    evictionRequirements: [] # Eviction requirements
  resourcePolicy:
    containerPolicies: [] # Container-specific policies
      # Example:
      # - containerName: "*"
      #   maxAllowed:
      #     cpu: "2"
      #     memory: "4Gi"
      #   minAllowed:
      #     cpu: "100m"
      #     memory: "128Mi"
    maxAllowed: {} # Global max allowed resources
    minAllowed: {} # Global min allowed resources
  recommenders: [] # Custom recommenders

# DNS policy for pods
# dnsPolicy: "None"
# DNS configuration
# dnsConfig:
#   nameservers: []
#     # - 1.2.3.4
#   searches: []
#     # - ns1.svc.cluster-domain.example
#     # - my.dns.search.suffix
#   options: []
#     # - name: ndots
#     #   value: "2"
#     # - name: edns0

# CloudNativePG Configuration
# Enable this to deploy a CloudNativePG PostgreSQL cluster
cnpg:
  enabled: false
  
  # Cluster configuration
  cluster:
    # Name of the cluster (defaults to fullname if not set)
    name: ""
    
    # Number of PostgreSQL instances
    instances: 3
    
    # PostgreSQL version
    postgresVersion: 16
    
    # Storage configuration
    storage:
      size: 50Gi
      storageClass: ""  # Uses default if not specified
      
    # Resource requests and limits
    resources:
      requests:
        cpu: "1"
        memory: "2Gi"
      limits:
        cpu: "2"
        memory: "4Gi"
    
    # PostgreSQL configuration parameters
    postgresql:
      parameters:
        max_connections: "200"
        shared_buffers: "512MB"
        effective_cache_size: "1536MB"
        maintenance_work_mem: "128MB"
        checkpoint_completion_target: "0.9"
        wal_buffers: "16MB"
        default_statistics_target: "100"
        random_page_cost: "1.1"
        effective_io_concurrency: "200"
        work_mem: "2621kB"
        min_wal_size: "1GB"
        max_wal_size: "4GB"
    
    # Database initialization
    bootstrap:
      initdb:
        database: "app"
        owner: "app"
        # encoding: UTF8
        # locale: en_US.UTF-8
    
    # Monitoring configuration
    monitoring:
      enabled: true
      # Prometheus PodMonitor settings
      podMonitor:
        enabled: true
        
    # Pod anti-affinity to spread instances across nodes/zones
    affinity:
      enablePodAntiAffinity: true
      topologyKey: "topology.kubernetes.io/zone"
      
    # Node selector
    nodeSelector: {}
    
    # Tolerations
    tolerations: []
  
  # Backup configuration
  backup:
    enabled: false
    
    # Backup schedule (cron format)
    schedule: "0 */1 * * *"  # Hourly by default
    
    # Backup retention policy
    retentionPolicy: "7d"
    
    # S3 backup configuration
    s3:
      enabled: false
      bucket: ""
      path: "/"
      region: "us-west-1"
      # Service account name for IRSA (leave empty to auto-generate)
      serviceAccountName: ""
      # IAM role ARN for IRSA
      roleArn: ""
    
    # WAL archiving for Point-in-Time Recovery
    wal:
      enabled: true
      compression: "gzip"
  
  # Connection pooler configuration (PgBouncer)
  pooler:
    enabled: false
    
    # Number of pooler instances
    instances: 3
    
    # Pool mode: session, transaction, or statement
    poolMode: "transaction"
    
    # PgBouncer configuration parameters
    parameters:
      max_client_conn: "1000"
      default_pool_size: "25"
      pool_mode: "transaction"
      
    # Resource requests and limits for pooler
    resources:
      requests:
        cpu: "100m"
        memory: "128Mi"
      limits:
        cpu: "500m"
        memory: "512Mi"
    
    # Pooler service type
    service:
      type: ClusterIP

# Strimzi Kafka Configuration
# Enable this to deploy a Strimzi Kafka cluster
kafka:
  enabled: false
  
  # Cluster configuration
  cluster:
    # Name of the cluster (defaults to fullname if not set)
    name: ""
    
    # Kafka version
    version: "3.8.0"
    
    # Metadata version for KRaft mode
    metadataVersion: "3.8-IV0"
    
    # Number of Kafka replicas (ignored if using KRaft node pools)
    replicas: 3
    
    # Kafka listeners configuration
    listeners:
      - name: plain
        port: 9092
        type: internal
        tls: false
      - name: tls
        port: 9093
        type: internal
        tls: true
    
    # Kafka configuration
    config:
      offsets.topic.replication.factor: 3
      transaction.state.log.replication.factor: 3
      transaction.state.log.min.isr: 2
      default.replication.factor: 3
      min.insync.replicas: 2
      inter.broker.protocol.version: "3.8"
      log.message.format.version: "3.8"
    
    # Storage configuration
    storage:
      type: jbod
      volumes:
        - id: 0
          type: persistent-claim
          size: 100Gi
          deleteClaim: false
    
    # Resource requests and limits
    resources:
      requests:
        cpu: "1"
        memory: "2Gi"
      limits:
        cpu: "2"
        memory: "4Gi"
    
    # JVM options
    jvmOptions:
      -Xms: 2048m
      -Xmx: 2048m
    
    # Pod anti-affinity to spread instances across nodes/zones
    affinity:
      enablePodAntiAffinity: true
      topologyKey: "topology.kubernetes.io/zone"
      
    # Node selector
    nodeSelector: {}
    
    # Tolerations
    tolerations: []
  
  # ZooKeeper configuration (for non-KRaft mode)
  zookeeper:
    enabled: false  # Set to true if not using KRaft mode
    replicas: 3
    
    storage:
      type: persistent-claim
      size: 10Gi
      deleteClaim: false
    
    resources:
      requests:
        cpu: "500m"
        memory: "1Gi"
      limits:
        cpu: "1"
        memory: "2Gi"
    
    jvmOptions:
      -Xms: 512m
      -Xmx: 512m
  
  # KRaft mode configuration (recommended)
  kraft:
    enabled: true
    
    # Node pools for KRaft mode
    nodePools:
      - name: controller
        replicas: 3
        roles:
          - controller
        storage:
          type: jbod
          volumes:
            - id: 0
              type: persistent-claim
              size: 10Gi
              kraftMetadata: shared
              deleteClaim: false
        resources:
          requests:
            cpu: "500m"
            memory: "1Gi"
          limits:
            cpu: "1"
            memory: "2Gi"
        jvmOptions:
          -Xms: 512m
          -Xmx: 512m
      
      - name: broker
        replicas: 3
        roles:
          - broker
        storage:
          type: jbod
          volumes:
            - id: 0
              type: persistent-claim
              size: 100Gi
              kraftMetadata: shared
              deleteClaim: false
        resources:
          requests:
            cpu: "1"
            memory: "2Gi"
          limits:
            cpu: "2"
            memory: "4Gi"
        jvmOptions:
          -Xms: 2048m
          -Xmx: 2048m
  
  # Entity Operator configuration
  entityOperator:
    enabled: true
    
    topicOperator:
      enabled: true
      resources:
        requests:
          cpu: "100m"
          memory: "128Mi"
        limits:
          cpu: "500m"
          memory: "512Mi"
    
    userOperator:
      enabled: true
      resources:
        requests:
          cpu: "100m"
          memory: "128Mi"
        limits:
          cpu: "500m"
          memory: "512Mi"
  
  # Kafka topics to create
  topics: []
  # Example:
  # - name: my-topic
  #   topicName: my-topic
  #   partitions: 3
  #   replicas: 3
  #   config:
  #     retention.ms: 604800000  # 7 days
  #     segment.ms: 86400000     # 1 day
  
  # Kafka Connect configuration
  connect:
    enabled: false
    name: ""  # defaults to <fullname>-connect
    replicas: 1
    bootstrapServers: ""  # defaults to <fullname>-kafka-bootstrap:9092
    
    # TLS configuration
    tls:
      enabled: false
      secretName: ""  # defaults to <fullname>-cluster-ca-cert
    
    # Connect configuration
    config:
      group.id: connect-cluster
      offset.storage.topic: connect-cluster-offsets
      config.storage.topic: connect-cluster-configs
      status.storage.topic: connect-cluster-status
      config.storage.replication.factor: -1
      offset.storage.replication.factor: -1
      status.storage.replication.factor: -1
    
    # Resource requests and limits
    resources:
      requests:
        cpu: "500m"
        memory: "1Gi"
      limits:
        cpu: "1"
        memory: "2Gi"
    
    # Build configuration for custom connectors
    build:
      enabled: false
      output:
        type: docker
        image: ""  # e.g., my-registry.io/my-connect-cluster:latest
      plugins: []
      # Example:
      # - name: debezium-postgres-connector
      #   artifacts:
      #     - type: tgz
      #       url: https://repo1.maven.org/maven2/io/debezium/debezium-connector-postgres/2.5.0.Final/debezium-connector-postgres-2.5.0.Final-plugin.tar.gz
    
    # Template for pod configuration
    template:
      pod:
        nodeSelector: {}
        tolerations: []